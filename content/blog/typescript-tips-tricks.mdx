---
title: "TypeScript Tips and Tricks Every Developer Should Know"
date: "2024-03-05"
excerpt: "Master TypeScript with these practical tips and tricks that will make your code more robust and maintainable."
author: "Alex Chen"
image: ""
---

# TypeScript Tips and Tricks Every Developer Should Know

TypeScript has become the go-to language for building large-scale JavaScript applications. Here are some powerful tips to level up your TypeScript game.

## 1. Use Type Guards Effectively

Type guards help TypeScript narrow down types in conditional blocks.

```typescript
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

function processValue(value: string | number) {
  if (isString(value)) {
    // TypeScript knows value is string here
    console.log(value.toUpperCase());
  } else {
    // TypeScript knows value is number here
    console.log(value.toFixed(2));
  }
}
```

## 2. Leverage Union and Intersection Types

Combine types to create more flexible and precise type definitions.

```typescript
// Union: can be either type
type Status = 'idle' | 'loading' | 'success' | 'error';

// Intersection: must have properties of both types
type Employee = Person & { employeeId: string };
```

## 3. Use the `as const` Assertion

Make your literals more specific and prevent accidental mutations.

```typescript
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
} as const;

// config is now: { readonly apiUrl: "https://api.example.com"; readonly timeout: 5000; }
```

## 4. Master Utility Types

TypeScript provides built-in utility types that save you time.

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  password: string;
}

// Pick only certain properties
type UserProfile = Pick<User, 'id' | 'name' | 'email'>;

// Make all properties optional
type PartialUser = Partial<User>;

// Make all properties required
type RequiredUser = Required<User>;

// Omit certain properties
type PublicUser = Omit<User, 'password'>;
```

## 5. Use Template Literal Types

Create string types based on patterns.

```typescript
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type Endpoint = '/users' | '/posts' | '/comments';

// Creates: "GET /users" | "GET /posts" | "POST /users" | etc.
type APIRoute = `${HTTPMethod} ${Endpoint}`;
```

## 6. Generic Constraints

Use generic constraints to make your functions more type-safe.

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: 'John', age: 30 };
const name = getProperty(user, 'name'); // ✅ Works
// const invalid = getProperty(user, 'invalid'); // ❌ Error
```

## 7. Discriminated Unions

Create type-safe state machines with discriminated unions.

```typescript
type LoadingState = { status: 'loading' };
type SuccessState = { status: 'success'; data: string };
type ErrorState = { status: 'error'; error: Error };

type State = LoadingState | SuccessState | ErrorState;

function handleState(state: State) {
  switch (state.status) {
    case 'loading':
      return 'Loading...';
    case 'success':
      return state.data; // TypeScript knows data exists
    case 'error':
      return state.error.message; // TypeScript knows error exists
  }
}
```

## 8. The `satisfies` Operator

Validate that a value matches a type without widening the type.

```typescript
type Color = 'red' | 'green' | 'blue';

const palette = {
  primary: 'red',
  secondary: 'green',
} satisfies Record<string, Color>;

// palette.primary is still 'red', not string
```

## Conclusion

These TypeScript tips will help you write more type-safe, maintainable code. Remember, TypeScript's type system is powerful—take time to learn it deeply.

Keep exploring and happy typing! ⌨️
